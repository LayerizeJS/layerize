<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>services/schema-builder.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Base.html">Base</a></li><li><a href="Crud.html">Crud</a><ul class='methods'><li data-type='method'><a href="Crud.html#_delete">_delete</a></li><li data-type='method'><a href="Crud.html#_get">_get</a></li><li data-type='method'><a href="Crud.html#_insert">_insert</a></li><li data-type='method'><a href="Crud.html#_search">_search</a></li><li data-type='method'><a href="Crud.html#_update">_update</a></li><li data-type='method'><a href="Crud.html#delete">delete</a></li><li data-type='method'><a href="Crud.html#get">get</a></li><li data-type='method'><a href="Crud.html#insert">insert</a></li><li data-type='method'><a href="Crud.html#search">search</a></li><li data-type='method'><a href="Crud.html#update">update</a></li></ul></li><li><a href="Export.html">Export</a></li><li><a href="JsonValidator.html">JsonValidator</a></li><li><a href="Layerize.html">Layerize</a><ul class='methods'><li data-type='method'><a href="Layerize.html#.Base">Base</a></li><li data-type='method'><a href="Layerize.html#.Crud">Crud</a></li><li data-type='method'><a href="Layerize.html#.Layers">Layers</a></li><li data-type='method'><a href="Layerize.html#.Schemas">Schemas</a></li><li data-type='method'><a href="Layerize.html#.Tables">Tables</a></li><li data-type='method'><a href="Layerize.html#_buildTables">_buildTables</a></li><li data-type='method'><a href="Layerize.html#_initiateCore">_initiateCore</a></li><li data-type='method'><a href="Layerize.html#initiate">initiate</a></li><li data-type='method'><a href="Layerize.html#install">install</a></li><li data-type='method'><a href="Layerize.html#layers">layers</a></li><li data-type='method'><a href="Layerize.html#loadControlledSchemas">loadControlledSchemas</a></li><li data-type='method'><a href="Layerize.html#loadSchemaListFromDB">loadSchemaListFromDB</a></li><li data-type='method'><a href="Layerize.html#uninstall">uninstall</a></li><li data-type='method'><a href="Layerize.html#updateAll">updateAll</a></li><li data-type='method'><a href="Layerize.html#validateSchemaVersions">validateSchemaVersions</a></li></ul></li><li><a href="Layers.html">Layers</a><ul class='methods'><li data-type='method'><a href="Layers.html#_applyFilters">_applyFilters</a></li><li data-type='method'><a href="Layers.html#_attachListToObject">_attachListToObject</a></li><li data-type='method'><a href="Layers.html#_attachToObject">_attachToObject</a></li><li data-type='method'><a href="Layers.html#_createTransaction">_createTransaction</a></li><li data-type='method'><a href="Layers.html#_dbFilter">_dbFilter</a></li><li data-type='method'><a href="Layers.html#_esFilter">_esFilter</a></li><li data-type='method'><a href="Layers.html#_includes">_includes</a></li><li data-type='method'><a href="Layers.html#_narrowedSchema">_narrowedSchema</a></li><li data-type='method'><a href="Layers.html#_stringToObjectFilters">_stringToObjectFilters</a></li><li data-type='method'><a href="Layers.html#_validate">_validate</a></li><li data-type='method'><a href="Layers.html#_validateFilter">_validateFilter</a></li><li data-type='method'><a href="Layers.html#clearAllTablesCache">clearAllTablesCache</a></li><li data-type='method'><a href="Layers.html#clearRecordCache">clearRecordCache</a></li><li data-type='method'><a href="Layers.html#clearTableCache">clearTableCache</a></li><li data-type='method'><a href="Layers.html#combine">combine</a></li><li data-type='method'><a href="Layers.html#commit">commit</a></li><li data-type='method'><a href="Layers.html#count">count</a></li><li data-type='method'><a href="Layers.html#delete">delete</a></li><li data-type='method'><a href="Layers.html#deleteByFilter">deleteByFilter</a></li><li data-type='method'><a href="Layers.html#deleteMany">deleteMany</a></li><li data-type='method'><a href="Layers.html#get">get</a></li><li data-type='method'><a href="Layers.html#getMany">getMany</a></li><li data-type='method'><a href="Layers.html#insert">insert</a></li><li data-type='method'><a href="Layers.html#insertMany">insertMany</a></li><li data-type='method'><a href="Layers.html#patch">patch</a></li><li data-type='method'><a href="Layers.html#patchByFilter">patchByFilter</a></li><li data-type='method'><a href="Layers.html#patchMany">patchMany</a></li><li data-type='method'><a href="Layers.html#rawCache">rawCache</a></li><li data-type='method'><a href="Layers.html#rawDatabase">rawDatabase</a></li><li data-type='method'><a href="Layers.html#rawSearch">rawSearch</a></li><li data-type='method'><a href="Layers.html#reindexSearch">reindexSearch</a></li><li data-type='method'><a href="Layers.html#rollback">rollback</a></li><li data-type='method'><a href="Layers.html#search">search</a></li><li data-type='method'><a href="Layers.html#transaction">transaction</a></li><li data-type='method'><a href="Layers.html#update">update</a></li><li data-type='method'><a href="Layers.html#updateMany">updateMany</a></li></ul></li><li><a href="SchemaBuilder.html">SchemaBuilder</a><ul class='methods'><li data-type='method'><a href="SchemaBuilder.html#layerize">layerize</a></li><li data-type='method'><a href="SchemaBuilder.html#load">load</a></li></ul></li><li><a href="Schemas.html">Schemas</a><ul class='methods'><li data-type='method'><a href="Schemas.html#_delete">_delete</a></li><li data-type='method'><a href="Schemas.html#_get">_get</a></li><li data-type='method'><a href="Schemas.html#_insert">_insert</a></li><li data-type='method'><a href="Schemas.html#_search">_search</a></li><li data-type='method'><a href="Schemas.html#_update">_update</a></li><li data-type='method'><a href="Schemas.html#delete">delete</a></li><li data-type='method'><a href="Schemas.html#get">get</a></li><li data-type='method'><a href="Schemas.html#insert">insert</a></li><li data-type='method'><a href="Schemas.html#search">search</a></li><li data-type='method'><a href="Schemas.html#update">update</a></li></ul></li><li><a href="Tables.html">Tables</a><ul class='methods'><li data-type='method'><a href="Tables.html#_delete">_delete</a></li><li data-type='method'><a href="Tables.html#_get">_get</a></li><li data-type='method'><a href="Tables.html#_insert">_insert</a></li><li data-type='method'><a href="Tables.html#_search">_search</a></li><li data-type='method'><a href="Tables.html#_update">_update</a></li><li data-type='method'><a href="Tables.html#delete">delete</a></li><li data-type='method'><a href="Tables.html#get">get</a></li><li data-type='method'><a href="Tables.html#insert">insert</a></li><li data-type='method'><a href="Tables.html#search">search</a></li><li data-type='method'><a href="Tables.html#update">update</a></li></ul></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">services/schema-builder.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const debug = require('debug')('layerize:schemas');
const glob = require('glob');
const fs = require('fs');
const extend = require('extend');
const { errors, layerizeSchema, objects } = require('../utils');
const { parseRefs } = layerizeSchema;
const pjson = require('../../package.json');

/**
 * The SchemaBuilder class loads provided json schema files into Layerize format.
 */
class SchemaBuilder {

    /**
     * Create a SchemaBuilder.
     * @param {object} config - available config
     * @param {JsonValidator} config.validator - an instance of a JsonValidator
     */
    constructor ({ validator = {} } = {}) {

        this.debug = debug;
        this.error = errors;
        this.validator = validator;

    }

    /**
     * loads provided json schema files into Layerize format.
     * @param {string} schemaPattern - a file pattern to schema locations
     * @returns {Promise&lt;object>} elasticsearch body object
     */
    async load (schemaPattern = '') {

        this.debug('load()');
        try {

            let schemas = {
                version: pjson.version,
                hash: '',
                raw: [],
                layerize: {},
                includes: {}
            };

            let schemaFiles = glob.sync(schemaPattern);
            let arySchemas = [];

            this.debug(` -- Found ${schemaFiles.length} schema files.`);

            for (let i = 0; i &lt; schemaFiles.length; i++) {

                let schema = JSON.parse(fs.readFileSync(schemaFiles[i], 'utf8'));
                if (schemaFiles[i].indexOf('_layerize.json') > -1) {

                    /**
                     * Remove properties that can not be overwritten
                     */
                    delete schema.hash;
                    delete schema.raw;
                    delete schema.layerize;

                    schemas = extend(true, schemas, schema);

                } else {

                    schema.$async = true;
                    arySchemas.push(schema);

                    if (this.validator.validateSchema(schema) === false) {

                        this.debug(this.validator.errors);

                    }

                }

            }

            if (arySchemas.length > 0) {

                this.validator.addSchema(arySchemas);
                this.debug(` -- Loaded ${arySchemas.length} schema files.`);

                for (let i = 0; i &lt; arySchemas.length; i++) {

                    let objSchema = arySchemas[i];

                    let id = objSchema.$id || '';
                    let schema = parseRefs({ jsonSchema: this.validator.getSchema(id) });

                    if (schema !== null) {

                        schemas.raw.push(schema);

                    }

                }

            }

            return await this.layerize({ schemas });

        } catch (error) {

            throw this.error.handle({ error, caller: 'load' });

        }

    }

    /**
     * loads provided json schema files into Layerize format.
     * @param {object} layerize - a file pattern to schema locations
     * @returns {Promise&lt;object>} elasticsearch body object
     */
    async layerize ({ schemas = {} } = {}) {

        this.debug('layerize()');
        try {

            /**
             * private internal function for layerize
             * @access private
             * @param {string} schema - schema
             * @param {object} details - details
             * @returns {object} returns object
             */
            let recursive = (schema, { properties = {}, dynamicDefaults = {}, required = [], elasticSearch } = {}) => {

                if (typeof schema.allOf !== 'undefined' &amp;&amp; typeof schema.properties !== 'undefined') {

                    throw new Error('Property name \'properties\' must reside within property \'allOf\' when being used together.');

                }

                if (typeof schema.allOf !== 'undefined') {

                    for (let x = 0; x &lt; schema.allOf.length; x++) {

                        ({ properties, dynamicDefaults, required, elasticSearch } = recursive(schema.allOf[x], { properties, dynamicDefaults, required, elasticSearch }));

                    }

                } else {

                    if (typeof schema.dynamicDefaults !== 'undefined') {

                        dynamicDefaults = extend(true, dynamicDefaults, schema.dynamicDefaults);

                    }

                    if (typeof schema.required !== 'undefined' &amp;&amp; schema.required.length > 0) {

                        required = required.concat(schema.required);

                    }

                    if (typeof schema.elasticSearch !== 'undefined') {

                        elasticSearch = extend(true, elasticSearch, schema.elasticSearch);

                    }

                    let props = Object.keys(schema.properties || {});
                    for (let x = 0; x &lt; props.length; x++) {

                        properties[props[x]] = schema.properties[props[x]];

                    }

                }

                if (schema.$root) {

                    if (typeof schema.dynamicDefaults !== 'undefined') {

                        dynamicDefaults = extend(true, dynamicDefaults, schema.dynamicDefaults);

                    }

                    if (typeof schema.elasticSearch !== 'undefined') {

                        elasticSearch = extend(true, elasticSearch, schema.elasticSearch);

                    }

                }

                return { properties, dynamicDefaults, required, elasticSearch };

            };

            schemas.raw.sort(objects.sortBy({ name: '$id' }));
            for (let i = 0; i &lt; schemas.raw.length; i++) {

                let schema = schemas.raw[i];
                let properties = {};
                let dynamicDefaults = {};
                let elasticSearch = {};
                let required = [];

                ({ properties, dynamicDefaults, required, elasticSearch } = recursive(schema, { properties, dynamicDefaults, required, elasticSearch }));

                let table = {
                    name: schema.$id,
                    version: schemas.version,
                    primaryKey: '',
                    timestamps: [],
                    includes: {},
                    columns: {},
                    esIndex: {},
                    esEnabled: false,
                    dbEnabled: true,
                    cacheEnabled: false,
                    dynamicDefaults,
                    properties,
                    required,
                    indexes: []
                };

                let esProperties = {};

                if (typeof schemas.includes[table.name] === 'undefined') {

                    schemas.includes[table.name] = {
                        referenced: {},
                        source: {}
                    };

                }

                let propertyNames = Object.keys(properties);
                for (let x = 0; x &lt; propertyNames.length; x++) {

                    let propertyName = propertyNames[x];
                    let property = properties[propertyName];
                    let column = {
                        name: propertyName,
                        type: property.type,
                        serial: Boolean(property.serial),
                        nullable: (typeof property.nullable === 'undefined') ? true : Boolean(property.nullable),
                        primary: Boolean(property.primaryKey),
                        unique: Boolean(property.unique)
                    };
                    let esType = 'keyword';

                    if (table.primaryKey === '' &amp;&amp; column.primary) {

                        table.primaryKey = column.name;

                    }

                    if (column.serial === false) {

                        delete column.serial;

                    } else {

                        column.nullable = false;

                    }

                    if (column.primary === false) {

                        delete column.primary;

                    } else {

                        column.nullable = false;

                    }

                    if (column.unique === false || column.primary === true) {

                        delete column.unique;

                    }

                    if (typeof property.default !== 'undefined') {

                        column.default = property.default;

                    }

                    if (typeof property.database !== 'undefined' &amp;&amp; typeof property.database.default !== 'undefined') {

                        column.default = property.database.default;

                    }

                    if (typeof property.foreign !== 'undefined') {

                        column.foreign = property.foreign;

                        if (typeof property.foreign.reference === 'undefined') {

                            throw new Error(`Property '${propertyName}' within table '${table.name}' is missing the 'reference' property inside 'foriegn' declaration.`);

                        }

                        if (typeof property.foreign.reference.column === 'undefined') {

                            throw new Error(`Property '${propertyName}' within table '${table.name}' is missing the 'column' property inside 'foriegn.reference' declaration.`);

                        }

                        if (typeof property.foreign.reference.table === 'undefined') {

                            throw new Error(`Property '${propertyName}' within table '${table.name}' is missing the 'table' property inside 'foriegn.reference' declaration.`);

                        }

                        if (typeof property.foreign.reference.relationship === 'undefined') {

                            throw new Error(`Property '${propertyName}' within table '${table.name}' is missing the 'relationship' property inside 'foriegn.reference' declaration.`);

                        }

                        let includeId = property.foreign.reference.table;
                        if (typeof property.foreign.reference.includeId !== 'undefined' &amp;&amp; property.foreign.reference.includeId !== '') {

                            includeId = property.foreign.reference.includeId;

                        }

                        let sourceIncludeId = table.name;
                        if (typeof property.foreign.source !== 'undefined' &amp;&amp; typeof property.foreign.source.includeId !== 'undefined' &amp;&amp; property.foreign.source.includeId !== '') {

                            sourceIncludeId = property.foreign.source.includeId;

                        }

                        if (typeof table.includes[includeId] !== 'undefined') {

                            throw new Error(`Property '${propertyName}' within table '${table.name}' needs to have a unique 'includeId', it is already being used by '${table.includes[includeId].table} -> ${table.includes[includeId].column}'.`);

                        }

                        column.foreign.reference = {
                            propertyTable: table.name,
                            property: propertyName,
                            table: property.foreign.reference.table,
                            column: property.foreign.reference.column,
                            relationship: property.foreign.reference.relationship,
                            includeId
                        };

                        if (typeof schemas.includes[property.foreign.reference.table] === 'undefined') {

                            schemas.includes[property.foreign.reference.table] = {
                                referenced: {},
                                source: {}
                            };

                        }

                        schemas.includes[table.name].source[includeId] = column.foreign.reference;
                        schemas.includes[property.foreign.reference.table].referenced[sourceIncludeId] = column.foreign.reference;

                        table.includes[includeId] = column.foreign.reference;

                    }

                    if (typeof property.scale !== 'undefined') {

                        column.scale = property.scale;

                    }

                    if (typeof property.readOnly !== 'undefined') {

                        column.readOnly = property.readOnly;

                    }

                    if (typeof property.definableOnCreate !== 'undefined') {

                        column.definableOnCreate = property.definableOnCreate;

                    }

                    if (typeof property.precision !== 'undefined') {

                        column.precision = property.precision;

                    }

                    switch (property.type) {

                        case 'array':

                            esType = 'object';
                            column.type = 'jsonb';

                            if (typeof property.default === 'undefined') {

                                column.default = [];

                            }

                            break;

                        case 'object':

                            esType = 'object';
                            column.type = 'jsonb';

                            if (typeof property.default === 'undefined') {

                                column.default = {};

                            }

                            break;

                        case 'boolean':

                            esType = 'boolean';
                            column.type = 'boolean';
                            break;

                        case 'integer':

                            esType = 'double';
                            if (property.serial) {

                                column.type = 'increments';

                            } else {

                                column.type = 'integer';

                            }
                            break;

                        default:

                            if (typeof property.maxLength !== 'undefined') {

                                column.length = property.maxLength;

                            }

                            switch (property.format) {

                                case 'date-time':

                                    if (property.timestamp) {

                                        column.type = 'timestamp';

                                    } else {

                                        column.type = 'dateTime';

                                    }

                                    esType = 'date';

                                    break;

                                case 'uuid':

                                    column.type = 'string';
                                    column.length = 36;
                                    esType = 'keyword';
                                    break;

                                case 'text':

                                    column.type = 'text';
                                    esType = 'text';
                                    break;

                                default:

                                    esType = 'keyword';
                                    column.type = 'string';

                            }
                            break;

                    }

                    /**
                     * table MUST enable elasticSeach for any ES properties to be recongized
                     */
                    if (elasticSearch.enabled) {

                        /**
                         * only add proeprty if elasticsearch is enabled, which 'undefined' equal to enabled:true
                         */
                        if (typeof property.elasticSearch === 'undefined' || (typeof property.elasticSearch !== 'undefined' &amp;&amp; (typeof property.elasticSearch.enabled === 'undefined' || property.elasticSearch.enabled === true))) {

                            table.esEnabled = true;

                            esProperties[propertyName] = {
                                type: esType
                            };

                            if (typeof property.default !== 'undefined') {

                                esProperties[propertyName].null_value = property.default;

                            }

                            if (property.properties) {

                                esProperties[propertyName].properties = property.properties;

                            }

                            if (typeof property.elasticSearch !== 'undefined') {

                                esProperties[propertyName] = extend(true, esProperties[propertyName], property.elasticSearch);

                            }

                        }

                    }

                    column.hash = objects.hash(column);
                    table.columns[column.name] = column;

                    if (column.type === 'timestamp') {

                        table.timestamps.push({ name: column.name });

                    }

                }

                if (elasticSearch.enabled) {

                    table.esIndex = extend(true, {}, elasticSearch);
                    delete table.esIndex.enabled;
                    table.esIndex.properties = esProperties;

                }

                // validate required
                for (let x = 0; x &lt; table.required.length; x++) {

                    if (typeof table.columns[table.required[x]] === 'undefined') {

                        throw new Error(`Property '${table.required[x]}' is required but is not defined in '${table.name}'.`);

                    }

                }

                this.debug(` -- Load layerize table schema '${table.name}'`);

                table.hash = objects.hash(table);
                schemas.layerize[table.name] = table;

            }

            /**
             * create hash of all hashes to quickly know if something has changed
             */
            let hashes = Object.keys(schemas.layerize).map(tableName => schemas.layerize[tableName].hash);
            hashes.unshift(schemas.version);
            schemas.hash = objects.hash(hashes);

            return schemas;

        } catch (error) {

            throw this.error.handle({ error, caller: 'layerize' });

        }

    }

}

module.exports = SchemaBuilder;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Dec 07 2018 15:14:50 GMT-0500 (EST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>


</body>
</html>
